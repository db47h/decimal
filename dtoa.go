// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file implements Float-to-string conversion functions.
// It is closely following the corresponding implementation
// in strconv/ftoa.go, but modified and simplified for Float.

package decimal

import (
	"math"
	"strconv"
)

// Text converts the decimal floating-point number x to a string according
// to the given format and precision prec. The format is one of:
//
//	'e'	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
//	'E'	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
//	'f'	-ddddd.dddd, no exponent
//	'g'	like 'e' for large exponents, like 'f' otherwise
//	'G'	like 'E' for large exponents, like 'f' otherwise
//	'x'	-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent
//	'p'	-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard)
//	'b'	-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)
//
// For the power-of-two exponent formats, the mantissa is printed in normalized form:
//
//	'x'	hexadecimal mantissa in [1, 2), or 0
//	'p'	hexadecimal mantissa in [½, 1), or 0
//	'b'	decimal integer mantissa using x.Prec() bits, or 0
//
// Note that the 'x' form is the one used by most other languages and libraries.
//
// If format is a different character, Text returns a "%" followed by the
// unrecognized format character.
//
// The precision prec controls the number of digits (excluding the exponent)
// printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
// For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
// For 'g' and 'G' it is the total number of digits. A negative precision selects
// the smallest number of decimal digits necessary to identify the value x uniquely
// using x.Prec() mantissa bits.
// The prec value is ignored for the 'b' and 'p' formats.
func (x *Decimal) Text(format byte, prec int) string {
	return string(x.Append(nil, format, prec))
}

// String formats x like x.Text('g', 10).
// (String must be called explicitly, Float.Format does not support %s verb.)
func (x *Decimal) String() string {
	return x.Text('g', 10)
}

func expSz(exp int32) int {
	if exp < 0 {
		return int(decDigits(uint(-exp))) + 1
	}
	return int(decDigits(uint(exp)))
}

// Append appends to buf the string form of the floating-point number x,
// as generated by x.Text, and returns the extended buffer.
func (x *Decimal) Append(buf []byte, fmt byte, prec int) []byte {
	shortest := false
	if prec < 0 {
		shortest = true
		digits := x.MinPrec()
		switch fmt {
		case 'e', 'E':
			prec = int(digits) - 1
		case 'f':
			prec = max(int(digits)-int(x.exp), 0)
		case 'g', 'G':
			prec = int(digits)
		}
	}
	if cap(buf) == 0 {
		buf = make([]byte, 0, x.bufSizeForFmt(fmt, prec))
	}

	// sign
	if x.neg {
		buf = append(buf, '-')
	}

	// Inf
	if x.form == inf {
		if !x.neg {
			buf = append(buf, '+')
		}
		return append(buf, "Inf"...)
	}

	switch fmt {
	case 'e', 'E':
		return x.fmtE(buf, fmt, prec)
	case 'f':
		return x.fmtF(buf, prec)
	case 'g', 'G':
		// trim trailing fractional zeros in %e format
		digits := int(x.MinPrec())
		eprec := prec
		if eprec > digits && digits >= int(x.exp) {
			eprec = digits
		}
		// %e is used if the exponent is less than -4 or greater than or
		// equal to the precision. If precision was the shortest possible,
		// use eprec = 6 for this decision.
		if shortest {
			eprec = 6
		}
		exp := int(x.exp) - 1
		if exp < -4 || exp >= eprec {
			if prec > digits {
				prec = digits
			}
			return x.fmtE(buf, fmt+'e'-'g', prec-1)
		}
		if prec > int(x.exp) {
			prec = digits
		}
		return x.fmtF(buf, max(prec-int(x.exp), 0))
	case 'p', 'b', 'x':
		// hand over binary formats to big.Float
		f, _ := x.Float(0)
		if x.neg {
			buf = buf[:len(buf)-1] // sign was added prematurely - remove it again
		}
		return f.Append(buf, fmt, prec)
	}

	// unknown format
	if x.neg {
		buf = buf[:len(buf)-1] // sign was added prematurely - remove it again
	}
	return append(buf, '%', fmt)
}

// digitsForFmt returns the estimated buffer size required to represent x in
// format fmt with precision prec.
func (x *Decimal) bufSizeForFmt(fmt byte, prec int) int {
	digits := int(x.MinPrec())
	if digits == 0 {
		digits = 1
	}
	var sz int
	if x.neg {
		sz++
	}
	switch fmt {
	case 'e', 'E':
		sz += 2 + expSz(x.exp)
		if prec < 0 {
			sz += digits
		} else {
			sz += prec + 1
		}
	case 'f':
		sz += 1
		if prec < 0 {
			sz += digits
			if x.exp < 0 || int(x.exp) > digits {
				sz += abs(int(x.exp))
			}
		} else {
			sz += max(int(x.exp), 1) + prec
		}
	case 'g':
		sz += 2 + expSz(x.exp)
		if prec < 0 {
			sz += digits
		} else {
			sz += prec
		}
	case 'x':
		sz += 4 + expSz(x.exp)
		if prec < 0 {
			sz += int(baseDigits(16, uint(digits)))
		} else {
			intLen := max(int(x.exp), 1)
			sz += int(baseDigits(16, uint(intLen))) + prec
		}
	case 'b':
		// despite needed conversion to base 2, the decimal mantissa should
		// have the same digit count.
		sz += 1 + digits + 1 + expSz(int32(float64(x.exp)*log2_10))
	case 'p':
		sz += 4 + int(baseDigits(16, uint(digits))) + expSz(x.exp)
	default:
		sz = prec
	}

	return max(4, sz)
}

func baseDigits(base uint, n uint) uint {
	if n == 0 {
		return 1
	}
	return uint(math.Log(float64(n))*math.Ln10/math.Log(float64(base))) + 1
}

// %f: ddddddd.ddddd
// prec is # of digits after decimal point
func (x *Decimal) fmtF(buf []byte, prec int) []byte {
	digits := int(x.MinPrec())

	// round
	if rnd := max(int(x.exp)+prec, 0); rnd < digits {
		// round down to requested precision
		// TODO(db47h): optimize copy of mantissa by limiting it to the relevant digits
		x = new(Decimal).Copy(x).SetPrec(uint(rnd))
		digits = int(x.MinPrec())
	}

	mant := x.mant.utoa(10)
	// integer, padded with zeros as needed
	if x.exp > 0 {
		m := min(digits, int(x.exp))
		buf = append(buf, mant[:m]...)
		for ; m < int(x.exp); m++ {
			buf = append(buf, '0')
		}
	} else {
		buf = append(buf, '0')
	}

	// fraction
	if prec > 0 {
		buf = append(buf, '.')
		for i := 0; i < prec; i++ {
			n := int(x.exp) + i
			var ch byte = '0'
			if 0 <= n && n < len(mant) {
				ch = mant[n]
			}
			buf = append(buf, ch)
		}
	}

	return buf
}

// %e: d.ddddde±dd
// prec is # of digits after decimal point
func (x *Decimal) fmtE(buf []byte, fmt byte, prec int) []byte {
	// round
	if prec+1 < int(x.MinPrec()) {
		x = new(Decimal).Copy(x).SetPrec(uint(prec + 1))
	}

	mant := x.mant.utoa(10)
	// trim trailing zeros
	n := len(mant)
	for n > 0 && mant[n-1] == '0' {
		n--
	}
	mant = mant[:n]

	// first digit
	ch := byte('0')
	if len(mant) > 0 {
		ch = mant[0]
	}
	buf = append(buf, ch)

	// .moredigits
	if prec > 0 {
		buf = append(buf, '.')
		i := 1
		m := min(len(mant), prec+1)
		if i < m {
			buf = append(buf, mant[i:m]...)
			i = m
		}
		for ; i <= prec; i++ {
			buf = append(buf, '0')
		}
	}

	// e±
	buf = append(buf, fmt)
	var exp int64
	if len(mant) > 0 {
		exp = int64(x.exp) - 1 // -1 because first digit was printed before '.'
	}
	if exp < 0 {
		ch = '-'
		exp = -exp
	} else {
		ch = '+'
	}
	buf = append(buf, ch)

	// dd...d
	if exp < 10 {
		buf = append(buf, '0') // at least 2 exponent digits
	}
	return strconv.AppendInt(buf, exp, 10)
}

// // Format implements fmt.Formatter. It accepts all the regular
// // formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
// // 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
// // interpretation of 'p'. The 'v' format is handled like 'g'.
// // Format also supports specification of the minimum precision
// // in digits, the output field width, as well as the format flags
// // '+' and ' ' for sign control, '0' for space or zero padding,
// // and '-' for left or right justification. See the fmt package
// // for details.
// func (x *Float) Format(s fmt.State, format rune) {
// 	prec, hasPrec := s.Precision()
// 	if !hasPrec {
// 		prec = 6 // default precision for 'e', 'f'
// 	}

// 	switch format {
// 	case 'e', 'E', 'f', 'b', 'p', 'x':
// 		// nothing to do
// 	case 'F':
// 		// (*Float).Text doesn't support 'F'; handle like 'f'
// 		format = 'f'
// 	case 'v':
// 		// handle like 'g'
// 		format = 'g'
// 		fallthrough
// 	case 'g', 'G':
// 		if !hasPrec {
// 			prec = -1 // default precision for 'g', 'G'
// 		}
// 	default:
// 		fmt.Fprintf(s, "%%!%c(*big.Float=%s)", format, x.String())
// 		return
// 	}
// 	var buf []byte
// 	buf = x.Append(buf, byte(format), prec)
// 	if len(buf) == 0 {
// 		buf = []byte("?") // should never happen, but don't crash
// 	}
// 	// len(buf) > 0

// 	var sign string
// 	switch {
// 	case buf[0] == '-':
// 		sign = "-"
// 		buf = buf[1:]
// 	case buf[0] == '+':
// 		// +Inf
// 		sign = "+"
// 		if s.Flag(' ') {
// 			sign = " "
// 		}
// 		buf = buf[1:]
// 	case s.Flag('+'):
// 		sign = "+"
// 	case s.Flag(' '):
// 		sign = " "
// 	}

// 	var padding int
// 	if width, hasWidth := s.Width(); hasWidth && width > len(sign)+len(buf) {
// 		padding = width - len(sign) - len(buf)
// 	}

// 	switch {
// 	case s.Flag('0') && !x.IsInf():
// 		// 0-padding on left
// 		writeMultiple(s, sign, 1)
// 		writeMultiple(s, "0", padding)
// 		s.Write(buf)
// 	case s.Flag('-'):
// 		// padding on right
// 		writeMultiple(s, sign, 1)
// 		s.Write(buf)
// 		writeMultiple(s, " ", padding)
// 	default:
// 		// padding on left
// 		writeMultiple(s, " ", padding)
// 		writeMultiple(s, sign, 1)
// 		s.Write(buf)
// 	}
// }
